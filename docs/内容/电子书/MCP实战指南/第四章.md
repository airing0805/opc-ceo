# 第四章：进阶技巧与最佳实践

> 前几章我们学会了如何安装、配置和使用 MCP。现在，让我们更进一步，学习如何开发自己的 MCP 服务器，以及在使用 MCP 时需要注意的安全、性能和调试技巧。

---

## 4.1 开发自己的 MCP 服务器

当你发现现有的 MCP 服务器无法满足需求时，开发自己的服务器是最好的选择。MCP 提供了简洁的 SDK，让你可以快速构建功能强大的服务器。

### 4.1.1 选择开发语言

MCP 官方提供了两种语言的 SDK：

| 语言 | SDK 包 | 适用场景 |
|------|--------|----------|
| TypeScript | `@modelcontextprotocol/sdk` | 前端/全栈开发者，生态丰富 |
| Python | `mcp` | 数据科学/AI 开发者，上手简单

两者功能完全对等，选择你熟悉的语言即可。本节以 TypeScript 为例进行讲解。

### 4.1.2 最简服务器示例

创建一个最简单的 MCP 服务器只需要几步：

**第一步：初始化项目**

```bash
mkdir my-mcp-server
cd my-mcp-server
npm init -y
npm install @modelcontextprotocol/sdk zod
```

**第二步：创建服务器代码**

创建 `index.ts` 文件：

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// 创建服务器实例
const server = new McpServer({
  name: "my-first-server",
  version: "1.0.0",
});

// 注册一个简单的工具
server.tool(
  "greet",                           // 工具名称
  "向用户发送问候语",                  // 工具描述
  {
    name: z.string().describe("用户名称"),
  },
  async ({ name }) => {
    return {
      content: [
        {
          type: "text",
          text: `你好，${name}！欢迎使用 MCP。`,
        },
      ],
    };
  }
);

// 启动服务器
const transport = new StdioServerTransport();
await server.connect(transport);
```

**第三步：编译并运行**

```bash
npx tsc index.ts --module nodenext --target es2022
node index.js
```

就是这样！你刚刚创建了第一个 MCP 服务器。

### 4.1.3 工具参数校验

MCP 使用 Zod 库进行参数校验，确保 AI 传入的参数符合预期：

```typescript
import { z } from "zod";

// 定义复杂的参数结构
const searchParams = z.object({
  query: z.string().min(1).describe("搜索关键词"),
  limit: z.number().int().min(1).max(100).default(10).describe("返回结果数量"),
  filters: z.object({
    type: z.enum(["file", "folder", "all"]).default("all"),
    dateRange: z.object({
      start: z.string().datetime().optional(),
      end: z.string().datetime().optional(),
    }).optional(),
  }).optional(),
});

server.tool(
  "search",
  "在指定范围内搜索文件或内容",
  searchParams.shape,
  async (params) => {
    // params 已经通过校验，类型安全
    const { query, limit, filters } = params;
    // 执行搜索逻辑...
    return { content: [{ type: "text", text: `找到 ${limit} 个结果` }] };
  }
);
```

### 4.1.4 注册资源

除了工具，你还可以暴露资源供 AI 读取：

```typescript
// 注册静态资源
server.resource(
  "config",
  "config://app/settings",
  async (uri) => ({
    contents: [
      {
        uri: uri.href,
        mimeType: "application/json",
        text: JSON.stringify({ theme: "dark", language: "zh-CN" }),
      },
    ],
  })
);

// 注册动态资源（使用模板）
server.resource(
  "user-profile",
  new ResourceTemplate("users://{userId}/profile", { list: undefined }),
  async (uri, { userId }) => ({
    contents: [
      {
        uri: uri.href,
        mimeType: "application/json",
        text: JSON.stringify({ id: userId, name: "用户" + userId }),
      },
    ],
  })
);
```

### 4.1.5 注册提示词模板

提示词模板可以帮助用户快速执行常见任务：

```typescript
server.prompt(
  "analyze-code",
  "分析代码质量并给出改进建议",
  {
    code: z.string().describe("待分析的代码"),
    language: z.string().optional().describe("编程语言"),
  },
  ({ code, language }) => ({
    messages: [
      {
        role: "user",
        content: {
          type: "text",
          text: `请分析以下${language || ""}代码的质量，指出潜在问题并给出改进建议：\n\n\`\`\`\n${code}\n\`\`\``,
        },
      },
    ],
  })
);
```

---

## 4.2 安全最佳实践

MCP 服务器可以访问你的数据和系统，安全至关重要。

### 4.2.1 最小权限原则

只授予服务器完成任务所需的最小权限：

```typescript
// 错误示例：允许访问整个文件系统
server.tool("read-file", "读取文件", { path: z.string() }, ...);

// 正确示例：限制在特定目录内
const ALLOWED_DIR = "/Users/username/safe-folder";

server.tool(
  "read-file",
  "读取允许目录内的文件",
  { path: z.string() },
  async ({ path }) => {
    // 校验路径是否在允许范围内
    const resolvedPath = path.resolve(ALLOWED_DIR, path);
    if (!resolvedPath.startsWith(ALLOWED_DIR)) {
      throw new Error("无权访问此路径");
    }
    // 读取文件...
  }
);
```

### 4.2.2 敏感信息保护

永远不要在代码中硬编码敏感信息：

```typescript
// 错误示例：硬编码 API Key
const apiKey = "sk-xxxxx";  // 绝对不要这样做！

// 正确示例：使用环境变量
const apiKey = process.env.MY_API_KEY;
if (!apiKey) {
  throw new Error("请设置 MY_API_KEY 环境变量");
}
```

在配置文件中传入环境变量：

```json
{
  "mcpServers": {
    "my-server": {
      "command": "node",
      "args": ["path/to/server.js"],
      "env": {
        "MY_API_KEY": "your-api-key-here"
      }
    }
  }
}
```

### 4.2.3 输入验证

所有来自 AI 的输入都必须验证：

```typescript
import { z } from "zod";

// 使用 Zod 进行严格验证
const schema = z.object({
  email: z.string().email(),
  age: z.number().int().min(0).max(150),
  url: z.string().url(),
});

server.tool("submit-form", "提交表单", schema.shape, async (params) => {
  // params 已经过 Zod 验证，类型安全
  // ...
});
```

### 4.2.4 操作审计

记录关键操作，便于问题追溯：

```typescript
function logOperation(tool: string, params: any, result: any) {
  const log = {
    timestamp: new Date().toISOString(),
    tool,
    params: sanitize(params),  // 移除敏感信息
    success: !result.isError,
  };
  fs.appendFileSync("audit.log", JSON.stringify(log) + "\n");
}
```

---

## 4.3 性能优化建议

当 MCP 服务器处理大量数据或高频请求时，性能优化变得重要。

### 4.3.1 批量操作

将多个操作合并为一次请求：

```typescript
// 低效：每个文件单独读取
server.tool("read-single-file", ...);

// 高效：批量读取
server.tool(
  "read-files",
  "批量读取多个文件",
  { paths: z.array(z.string()).max(50) },
  async ({ paths }) => {
    const contents = await Promise.all(
      paths.map(path => fs.readFile(path, "utf-8"))
    );
    return {
      content: contents.map((text, i) => ({
        type: "text",
        text: `=== ${paths[i]} ===\n${text}`,
      })),
    };
  }
);
```

### 4.3.2 分页与懒加载

对于大量数据，使用分页避免一次返回过多：

```typescript
server.tool(
  "list-items",
  "分页列出项目",
  {
    page: z.number().int().min(1).default(1),
    pageSize: z.number().int().min(1).max(100).default(20),
  },
  async ({ page, pageSize }) => {
    const offset = (page - 1) * pageSize;
    const items = await db.query(
      "SELECT * FROM items LIMIT ? OFFSET ?",
      [pageSize, offset]
    );
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ items, page, hasMore: items.length === pageSize }),
      }],
    };
  }
);
```

### 4.3.3 缓存策略

对于不常变化的数据，添加缓存：

```typescript
const cache = new Map<string, { data: any; expiry: number }>();

async function withCache<T>(key: string, fetcher: () => T, ttlMs = 60000): T {
  const cached = cache.get(key);
  if (cached && Date.now() < cached.expiry) {
    return cached.data;
  }
  const data = await fetcher();
  cache.set(key, { data, expiry: Date.now() + ttlMs });
  return data;
}
```

---

## 4.4 调试技巧

### 4.4.1 启用调试日志

MCP SDK 支持日志级别控制：

```typescript
import { LogLevel } from "@modelcontextprotocol/sdk/types.js";

const server = new McpServer({
  name: "debug-server",
  version: "1.0.0",
}, {
  logging: { level: LogLevel.Debug },
});

// 发送调试日志到客户端
server.server.sendLoggingMessage({
  level: LogLevel.Debug,
  data: "这是一条调试信息",
});
```

### 4.4.2 使用 MCP Inspector

官方提供了 Inspector 工具，可以可视化调试 MCP 服务器：

```bash
npx @modelcontextprotocol/inspector node your-server.js
```

Inspector 提供：
- 查看服务器暴露的所有工具、资源、提示词
- 测试工具调用
- 查看请求/响应详情
- 检查错误信息

### 4.4.3 常见错误排查

| 错误现象 | 可能原因 | 解决方法 |
|----------|----------|----------|
| 服务器启动后立即退出 | 未正确连接传输层 | 检查 `server.connect(transport)` |
| 工具调用无响应 | 异步操作未返回 | 确保 tool handler 返回 Promise |
| 参数类型错误 | Zod schema 与实际不符 | 检查 AI 传入的参数格式 |
| 权限错误 | 文件/网络访问被拒绝 | 检查路径和权限设置 |

---

## 4.5 常见问题 FAQ

### Q1: MCP 服务器可以作为 HTTP 服务运行吗？

可以。MCP 支持多种传输方式：
- **Stdio**：标准输入输出（默认，适合本地）
- **HTTP+SSE**：适合远程访问
- **WebSocket**：适合实时交互

```typescript
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

const transport = new SSEServerTransport("/message", res);
await server.connect(transport);
```

### Q2: 如何处理需要用户确认的敏感操作？

使用 MCP 的采样功能，让 AI 请求用户确认：

```typescript
const result = await server.server.createMessage({
  messages: [{
    role: "user",
    content: { type: "text", text: "确定要删除这个文件吗？此操作不可恢复。" },
  }],
  maxTokens: 100,
});
// 根据用户回复决定是否执行
```

### Q3: 多个 MCP 服务器可以共享状态吗？

MCP 服务器是独立的进程，不直接共享状态。如果需要共享数据：
- 使用外部存储（数据库、Redis）
- 使用文件系统作为中转
- 通过 AI 客户端协调

### Q4: 如何限制 AI 的调用频率？

在服务器端实现简单的限流：

```typescript
const rateLimiter = new Map<string, number[]>();
const LIMIT = 10;  // 每分钟最多 10 次

function checkRateLimit(clientId: string): boolean {
  const now = Date.now();
  const calls = rateLimiter.get(clientId) || [];
  const recentCalls = calls.filter(t => now - t < 60000);
  if (recentCalls.length >= LIMIT) return false;
  recentCalls.push(now);
  rateLimiter.set(clientId, recentCalls);
  return true;
}
```

---

## 4.6 资源推荐

### 官方资源

| 资源 | 链接 | 说明 |
|------|------|------|
| MCP 官方文档 | [modelcontextprotocol.io](https://modelcontextprotocol.io/) | 最权威的协议文档 |
| MCP GitHub | [github.com/modelcontextprotocol](https://github.com/modelcontextprotocol) | 官方服务器和 SDK 源码 |
| Anthropic 博客 | [anthropic.com/news](https://www.anthropic.com/news) | MCP 发布和更新公告 |

### 社区资源

| 资源 | 说明 |
|------|------|
| [awesome-mcp-servers](https://github.com/punkpeye/awesome-mcp-servers) | 社区维护的 MCP 服务器合集 |
| [mcp-get](https://mcp-get.com/) | MCP 服务器发现和安装工具 |
| Discord 社区 | Anthropic 官方 Discord 的 MCP 频道 |

### 学习路径

1. **入门**：阅读官方文档的 Introduction 部分
2. **实践**：安装 2-3 个官方服务器，体验基本功能
3. **开发**：参考官方服务器源码，开发自己的服务器
4. **进阶**：探索高级特性（采样、根目录、完成功能）

---

## 4.7 未来发展方向

MCP 作为新生协议，正在快速发展。以下是一些值得关注的趋势：

### 4.7.1 协议演进

- **更多传输方式**：支持 gRPC、QUIC 等高性能协议
- **流式响应**：支持大文件和长时间操作的流式传输
- **双向主动通信**：服务器可主动向客户端推送消息

### 4.7.2 生态扩展

- **更多客户端支持**：OpenAI、Google 等可能采纳 MCP
- **企业级特性**：单点登录、审计日志、合规性支持
- **市场与分发**：类似 npm 的 MCP 服务器市场

### 4.7.3 AI 原生应用

- **Agent 编排**：MCP 作为多 Agent 协作的纽带
- **自主决策**：AI 自主发现和使用 MCP 服务
- **知识增强**：MCP 资源成为 AI 的长期记忆

---

## 4.8 本章小结

本章我们学习了 MCP 的进阶内容：

1. **开发服务器**：使用 TypeScript/Python SDK 创建工具、资源、提示词
2. **安全实践**：最小权限、敏感信息保护、输入验证、操作审计
3. **性能优化**：批量操作、分页、缓存
4. **调试技巧**：日志、Inspector、常见错误排查
5. **FAQ**：HTTP 服务、用户确认、状态共享、限流
6. **资源推荐**：官方文档、社区资源、学习路径
7. **未来方向**：协议演进、生态扩展、AI 原生应用

恭喜你完成了 MCP 实战指南的学习！现在你已经掌握了 MCP 的核心知识和实践技能。接下来，就是动手实践，将 MCP 应用到你的工作中，释放 AI 的真正潜力。

---

> **下一步建议**：
> 1. 选择一个你日常工作中重复性高的任务
> 2. 思考是否可以用 MCP 自动化
> 3. 开发一个小型 MCP 服务器
> 4. 在实际工作中使用和迭代

**愿 MCP 成为你的 AI 超能力！**
